# ==========================================================
#   PROJET : Chargeur hybride LiFePO‚ÇÑ 24V 300Ah (Optimis√© Victron)
#   Cha√Æne : AC ‚Üí Emerson/Vertiv R48 (48V) ‚Üí DPS5020 ‚Üí Batterie
#   Auteur : Pat (+ optimisation assist√©e)
#   Version : 1.6.8 - 2025-11-017
#   ‚úÖ Modifi√© le 2025-11-17 ‚Äì 
#   Points cl√©s :
#     - Watchdog Modbus DPS (Optimis√©) revu
#     - Logique de Fallback pour le Statut Victron (Mode S√©curit√©)
#     - Nettoyage scories ancien code
#   Version : 1.6.5 - 2025-11-05
#   ‚úÖ Modifi√© le 2025-11-05 ‚Äì Ajout protections nuit + Victron OFF (AC ne red√©marre plus automatiquement)
#   Points cl√©s :
#     - Phases de charge d√©l√©gu√©es au Victron (sensor.smartsolar1_esp_charging_mode) ‚Äì source de v√©rit√©
#     - Tensions LiFePO‚ÇÑ Victron vs DPS : DPS = Victron - 0.20 V (evite les conflits de r√©gulation)
#       * Bulk/Absorption Victron 28.6 V ‚Üí DPS 28.4 V
#       * Float Victron 27.1 V ‚Üí DPS 26.9 V
#     - DPS activ√© UNIQUEMENT si Victron est OK (bulk/absorption/float)
#     - Si Victron OFF/IDLE/NIGHT/FAULT ‚Üí DPS OFF + R48 AC OFF
#     - Transition OFF‚ÜíON du Victron ‚Üí R48 AC ON + 2s + start_sequence (non bloquant via scripts)
#     - Surveillances conserv√©es (CAN/Modbus/Temp/Surtension/Surintensit√©/WiFi)
#     - Debounce 2s + Slew 0.3V pour √©viter les √†-coups (init sur valeur r√©elle)
#     - Ajout d'une commande pour forcer la charge meme si victron OFF
#     - Modifi watchdog dps bloqu√© 
#     - correction compteurs Wh et KWH
#     - correction lev√© couch√© soleil
#     - conf r√©seau
# ==========================================================

substitutions:
  device_description: "Chargeur 1.6.8 LiFePO4 24V 300Ah via DPS5020 (pilot√© Victron)"
  limiter_name: limiter
  tx_pin: GPIO17
  rx_pin: GPIO16
  ota_pswd: !secret ota_pswd
  ap_pwd: !secret ota_pswd
  adress_ip: !secret ip_R48dps
  gateway_ip: !secret ip_gateway
  dns_ip: !secret ip_dns

esphome:
  name: charger-hybrid
  friendly_name: "Chargeur 1.6.8 Hybride Emerson + DPS5020 (Victron/shelly)"
  min_version: 2024.6.0
  comment: "R48 alimente le DPS5020 (charge LiFePO4 24V, mode pilot√© Victron, DPS -0.2V)"
  on_boot:
    priority: -100
    then:
      - delay: 2s
      - logger.log: "‚ö° ESP d√©marr√© ‚Äì AC R48 volontairement √©teint (s√©curit√©)"
      # ‚úÖ Emp√™che l'autostart la nuit si Victron n'est pas OK (sauf mode forc√©)
      - if:
          condition:
            lambda: |-
              std::string vm = id(victron_mode).state.c_str();
              for (auto &c : vm) c = tolower(c);
              bool victron_ok = (vm == "bulk" || vm == "absorption" || vm == "float");
              if (id(sun_down).state && !victron_ok && !id(force_charge_mode)) {
                ESP_LOGW("boot", "üåô Nuit + Victron OFF ‚Üí pas de start_sequence automatique au boot");
                return false;
              }
              return (millis() - id(last_start_ts)) > 15000;
          then:
            - script.execute: start_sequence
            - lambda: 'id(last_start_ts) = millis();'

esp32:
  board: esp32dev
  framework:
    type: arduino

# ==========================================================
# === LOGS
# ==========================================================
logger:
  level: INFO
  logs:
    emerson_r48: WARN
    mcp2515: INFO
    lazy_limiter: INFO
    limiter: INFO
    component: INFO
    dps: INFO

api:
  on_client_connected:
    - lambda: |-
        id(api_status) = true;
        id(api_connected).publish_state(true);
        ESP_LOGI("api", "‚úÖ Home Assistant connect√©");
  on_client_disconnected:
    - lambda: |-
        id(api_status) = false;
        id(api_connected).publish_state(false);
        ESP_LOGI("api", "‚ùå Home Assistant d√©connect√©");

ota:
  platform: esphome

# WiFi Component: https://esphome.io/components/wifi.html
## ---------------------------------------------------
## WIFI Settings 2 wifis
## ---------------------------------------------------
wifi:
  networks:
      ## domotique
    - ssid: !secret wifi_ssid
      password: !secret wifi_password
      priority: 0
      ### maison
    - ssid: !secret wifi_ssid2
      password: !secret wifi_password2
      priority: 1
  manual_ip:
    static_ip: ${adress_ip}
    gateway: ${gateway_ip}
    subnet: 255.255.255.0    
    dns1: ${dns_ip}
  #domain: !secret domain
  ap:
    # ssid (Optional, string): The name of the access point to create. Leave empty to use the device name.
    password: !secret ota_pswd

web_server:

# ==========================================================
# === EXTERNAL COMPONENTS
# ==========================================================
external_components:
  - source:
      type: git
      url: https://github.com/jon7119/esphomeemerson-vertiv-r48
      ref: main
    refresh: 0s
  - source: github://syssi/esphome-dps@main
    refresh: 0s

# ==========================================================
# === EMERSON R48 (CANBUS)
# ==========================================================
spi:
  id: shared_spi
  clk_pin: GPIO18
  mosi_pin: GPIO23
  miso_pin: GPIO19

canbus:
  - platform: mcp2515
    id: can
    spi_id: shared_spi
    use_extended_id: true
    cs_pin: GPIO5
    can_id: 0x0607FF83
    bit_rate: 125kbps
    clock: 8MHz   # module confirm√© 8 MHz

emerson_r48:
  canbus_id: can
  update_interval: 3s

time:
  - platform: sntp
    id: esphome_time
    servers: pool.ntp.org

button:
  - platform: emerson_r48
    set_offline_values:
      name: "R48 Set offline values"

  - platform: restart
    name: "Restart ESP"
    id: restart_esp

# ==========================================================
# === DPS5020 (UART + MODBUS)
# ==========================================================
uart:
  id: uart_0
  baud_rate: 9600
  tx_pin: ${tx_pin}
  rx_pin: ${rx_pin}

modbus:
  id: modbus0
  uart_id: uart_0
  send_wait_time: 50ms
  
dps:
  id: dps0
  modbus_id: modbus0
  update_interval: 5s

lazy_limiter:
  power_id: powermeter
  power_sensor_inactivity_timeout: 20s
  power_demand_calculation: NEGATIVE_MEASUREMENTS_REQUIRED
  min_power_demand: 50
  max_power_demand: 500
  buffer: 30
  update_interval: 3s

# ==========================================================
# === SCRIPTS (s√©quence de d√©marrage r√©utilisable + non-bloquants)
# ==========================================================
script:
  - id: start_sequence
    mode: queued
    then:
      # ‚úÖ S√©curit√© : ne pas d√©marrer si nuit + Victron OFF + pas en mode forc√©
      - lambda: |-
          std::string vm = id(victron_mode).state.c_str();
          for (auto &c : vm) c = tolower(c);
          bool victron_ok = (vm == "bulk" || vm == "absorption" || vm == "float");

          if (id(sun_down).state && !victron_ok && !id(force_charge_mode)) {
            ESP_LOGW("start", "üåô Nuit + Victron OFF ‚Üí start_sequence annul√©e (AC/DPS inchang√©s)");
            return;
          }

      - logger.log: "‚ö° S√©quence de d√©marrage d√©clench√©e"
      
      # ‚ö° AC R48 : cycle ON/OFF bref pour r√©initialisation
      - switch.turn_on: emerson_r48_ac_sw
      - delay: 1s
      - switch.turn_off: emerson_r48_ac_sw
      - delay: 2s

      # V√©rif CAN R48
      - wait_until:
          condition:
            lambda: 'return id(r48_output_voltage).has_state();'
          timeout: 7s
      - logger.log: "‚úÖ CAN R48 OK"

      # R√©glages R48
      - delay: 100ms
      - number.set:
          id: emerson_r48_output_voltage
          value: 48.0
      - number.set:
          id: emerson_r48_max_output_current
          value: 30
      - number.set:
          id: emerson_r48_max_input_current
          value: 5
      - logger.log: "‚öôÔ∏è R48 r√©gl√© : 48V / 30% / 5A AC"

      # Activer DC R48
      - switch.turn_off: emerson_r48_dc_sw
      - delay: 3s
      - logger.log: "‚ö° R48 ‚Üí 48V envoy√© vers DPS5020"

      # Tension par d√©faut DPS (pilot√©e ensuite par Victron)
      - number.set:
          id: voltage_setting
          value: 26.9
      - logger.log: "üîã Mode Victron : consigne DPS sera ajust√©e (DPS -0.2V)"

      # ‚úÖ Activer DPS uniquement si Victron OK
      - if:
          condition:
            lambda: |-
              std::string vm = id(victron_mode).state.c_str();
              for (auto &c : vm) c = tolower(c);
              return (vm == "bulk" || vm == "absorption" || vm == "float");
          then:
            - switch.turn_on: dps_output_sw
            - logger.log: "‚úÖ Victron OK ‚Üí DPS ON"
          else:
            - logger.log: "‚õî Victron non pr√™t ‚Üí DPS reste OFF"

  # Transition automatique Victron OFF ‚Üí ON (corrig√©e : respecte la nuit + non-forc√©)
  - id: seq_victron_ok
    mode: restart
    then:
      - lambda: |-
          std::string vm = id(victron_mode).state.c_str();
          for (auto &c : vm) c = tolower(c);
          bool victron_ok = (vm == "bulk" || vm == "absorption" || vm == "float");
          if (id(sun_down).state && !victron_ok && !id(force_charge_mode)) {
            ESP_LOGW("seq", "üåô Nuit + Victron pas en charge ‚Üí pas de rallumage AC via seq_victron_ok()");
            return;
          }
      - switch.turn_on: emerson_r48_ac_sw
      - delay: 2s
      - script.execute: start_sequence

  # Pr√©charge avant r√©activation DC apr√®s DPS ON
  - id: dc_rearm_after_dps_on
    mode: restart
    then:
      - delay: 3s
      - switch.turn_on: emerson_r48_dc_sw

  # Reset court DC R48 (pour watchdog CAN inactif)
  - id: r48_dc_reset_short
    mode: restart
    then:
      - switch.turn_off: emerson_r48_dc_sw
      - delay: 1s
      - switch.turn_on: emerson_r48_dc_sw


# ==========================================================
# === BINARY SENSORS
# ==========================================================
binary_sensor:

  - platform: template
    id: api_connected
    name: "API connect√©e"
    device_class: connectivity
    lambda: 'return id(api_status);'

  - platform: status
    name: "ESP Controller Status"

  - platform: dps
    output:
      id: dps_output
    key_lock:
      id: dps_key_lock
    constant_current_mode:
      name: "DPS constant current mode"

  - platform: template
    id: charger_active
    name: "Chargeur automatique actif"
    device_class: power
    lambda: |-
      return id(current_setting).state > 0.5f && id(dps_output_sw).state;

  # D√©tection retour secteur R48 (AC Voltage > 200V) avec hyst√©r√©sis via delays

  - platform: template
    id: r48_ac_present
    name: "R48 AC pr√©sent"
    device_class: power
    lambda: |-
      // Hyst√©r√©sis : ON >215 V, OFF <185 V
      static bool ac = false;
      if (!id(r48_ac_voltage).has_state()) return false;
      float vac = id(r48_ac_voltage).state;
      if (!ac && vac > 215.0f) ac = true;
      if (ac && vac < 185.0f)  ac = false;
      return ac;
    filters:
      - delayed_on: 3s
      - delayed_off: 3s
    on_press:
      then:
        - lambda: |-
            // Ne pas r√©agir si c‚Äôest nous qui venons de jouer avec l‚ÄôAC (fen√™tre 12 s)
            if (millis() - id(last_start_ts) < 12000) {
              ESP_LOGI("ac", "‚Ü©Ô∏è Retour AC ignor√© (fen√™tre mute post-sequence)");
              return;
            }
            // Optionnel : ne relancer que si Victron est en mode charge
            std::string vm = id(victron_mode).state.c_str();
            for (auto &c : vm) c = tolower(c);
            bool victron_ok = (vm == "bulk" || vm == "absorption" || vm == "float");
            if (!victron_ok) {
              ESP_LOGW("ac", "‚ö° AC de retour mais Victron non pr√™t (%s) ‚Üí on ne relance pas", vm.c_str());
              return;
            }
            ESP_LOGI("ac", "‚ö° Retour secteur stable d√©tect√© (>215 V) ‚Üí start_sequence");
            id(last_start_ts) = millis();
        - script.execute: start_sequence

# MODIFICATION ‚Äì Capteur pour savoir si le soleil est couch√©

  - platform: template
    id: sun_down
    name: "Soleil couch√©"
    lambda: |-
      if (!id(sun_state).has_state()) return false;        // MODIFICATION
      return id(sun_state).state == "below_horizon";        // MODIFICATION


# ==========================================================
# === SENSORS (Emerson + Limiteur + DPS + √ânergies)
# ==========================================================
sensor:
  # --- Emerson R48 ---
  - platform: emerson_r48
    output_voltage:
      name: "R48 Output voltage"
      id: r48_output_voltage
    output_current:
      name: "R48 Output current"
      id: r48_output_current
    output_temp:
      name: "R48 Temperature"
      id: r48_output_temp
    input_voltage:
      name: "R48 AC Voltage"
      id: r48_ac_voltage
    max_output_current:
      name: "R48 DC max current"
      unit_of_measurement: "%"

  # --- Puissance Emerson (entr√©e DPS5020) ---
  - platform: template
    name: "Puissance Emerson (entr√©e DPS)"
    id: outpower
    unit_of_measurement: "W"
    device_class: power
    update_interval: 6s
    accuracy_decimals: 1
    lambda: |-
      if (!id(dps_output_sw).state) return 0.0f;
      if (!id(r48_output_current).has_state() || !id(r48_output_voltage).has_state()) return 0.0f;
      float i = id(r48_output_current).state;
      if (i < 0.2f) return 0.0f; // seuil anti-bruit
      return i * id(r48_output_voltage).state;

  # --- Entr√©e Home Assistant : puissance instantan√©e msunpv (n√©gative = surplus) ---
  - platform: homeassistant
    internal: true
    id: powermeter
    name: "DPS smartmeter instantaneous power"
    entity_id: sensor.cptlinkyshe_power
    filters:
      - multiply: -1
      - throttle_average: 1s
      - lambda: |-
          // Hyst√©r√©sis + temporisation: ON si surplus >= 30W pendant 3s, OFF si <=10W pendant 5s
          static bool active = false;
          static unsigned long on_since = 0;
          static unsigned long off_since = 0;
          const float ON_W = 30.0f;
          const float OFF_W = 10.0f;
          const uint32_t ON_MS = 3000;
          const uint32_t OFF_MS = 5000;

          if (x >= ON_W) {
            if (on_since == 0) on_since = millis();
            if (!active && (millis() - on_since >= ON_MS)) {
              active = true;
              ESP_LOGI("limiter", "‚ö° Charge ON (%.1f W)", x);
            }
          } else {
            on_since = 0;
          }

          if (x <= OFF_W) {
            if (off_since == 0) off_since = millis();
            if (active && (millis() - off_since >= OFF_MS)) {
              active = false;
              ESP_LOGI("limiter", "üõë Charge OFF (%.1f W)", x);
            }
          } else {
            off_since = 0;
          }

          if (!active) x = 0.0;
          return round(x * 100.0) / 100.0;

  # --- Lazy limiter : demande de puissance ‚Üí consigne courant ---
  - platform: lazy_limiter
    power_demand:
      name: "${limiter_name} power demand"
      on_value:
        - lambda: |-
            // ‚úÖ Ne rien faire si DPS √©teint ou Victron pas pr√™t
            std::string vm = id(victron_mode).state.c_str();
            for (auto &c : vm) c = tolower(c);
            bool victron_ok = (vm == "bulk" || vm == "absorption" || vm == "float");
            if (!victron_ok || !id(dps_output_sw).state) {
              ESP_LOGD("lazy_limiter", "‚è∏ Limiter ignor√© (Victron=%s, DPS=%d)", vm.c_str(), id(dps_output_sw).state);
              id(current_setting).make_call().set_value(0).perform();  // optionnel : met √† z√©ro
              return;
            }

            // --- S√©curisation tension pour calcul courant
            float v_meas = id(dps_output_voltage).has_state() ? id(dps_output_voltage).state : 0.0f;
            float v_fallback = (id(dps_voltage_sensor).has_state() && id(dps_voltage_sensor).state > 1.0f) ? id(dps_voltage_sensor).state : 26.9f;
            float v_use = (v_meas > 1.0f) ? v_meas : v_fallback;

            // --- Puissance demand√©e (x du limiter)
            float pd = x;
            if (pd < 0) pd = 0;
            if (pd > 500) pd = 500;

            float amps = pd / v_use;
            if (amps > 19.5f) amps = 19.5f;

            id(current_setting).make_call().set_value(amps).perform();
            ESP_LOGI("lazy_limiter", "‚öôÔ∏è %.1f W -> %.2f V -> %.2f A", pd, v_use, amps);

  # --- DPS5020 (mesures natives) ---
  - platform: dps
    output_voltage:
      id: dps_output_voltage
      name: "DPS output voltage"
    output_current:
      id: dps_output_current
      name: "DPS output current"
    output_power:
      id: dps_output_power
      name: "DPS output power"
    input_voltage:
      name: "DPS input voltage"
    voltage_setting:
      id: dps_voltage_sensor
      name: "DPS voltage setting"
    current_setting:
      id: dps_current_sensor
      name: "DPS current setting"
    backlight_brightness:
      name: "DPS backlight brightness"
    firmware_version:
      name: "DPS firmware version"

  # --- √ânergie DPS (entr√©e historique) ---
  - platform: template
    id: dps_energy_wh
    name: "√ânergie autoconsomm√©e batterie (Wh)"
    unit_of_measurement: "Wh"
    accuracy_decimals: 1
    icon: "mdi:battery-arrow-up-outline"

  - platform: template
    id: dps_energy_kwh
    name: "√ânergie autoconsomm√©e batterie (kWh)"
    unit_of_measurement: "kWh"
    accuracy_decimals: 3
    icon: "mdi:battery-charging"
    lambda: |-
      return id(dps_energy_wh).state / 1000.0;

  # --- Puissance batterie estim√©e (avec rendement DPS) ---
  - platform: template
    id: battery_power_est
    name: "Puissance batterie estim√©e"
    unit_of_measurement: "W"
    device_class: power
    accuracy_decimals: 1
    update_interval: 6s
    lambda: |-
      const float efficiency = id(dps_efficiency).state / 100.0f;
      if (!id(r48_output_current).has_state() || !id(r48_output_voltage).has_state()) return 0.0f;
      if (!id(dps_output_sw).state) return 0.0f;
      float p_in = id(r48_output_current).state * id(r48_output_voltage).state;
      return p_in * efficiency;

  # --- √ânergie batterie estim√©e persistante ---
  - platform: template
    id: battery_energy_wh
    name: "√ânergie batterie estim√©e (Wh)"
    unit_of_measurement: "Wh"
    device_class: energy
    accuracy_decimals: 1
    update_interval: 10s
    icon: "mdi:battery-arrow-up-outline"
    lambda: |-
      static unsigned long last_time = millis();
      unsigned long now = millis();
      if (now < last_time) last_time = now;
      float delta_h = (now - last_time) / 3600000.0f;
      last_time = now;

      if (id(battery_power_est).has_state()) {
        float p = id(battery_power_est).state;
        if (p > 0.5f) {
          id(battery_energy_wh_total) += p * delta_h;
        }
      }

      // ‚úÖ Publication syst√©matique (m√™me si 0W)
      float result = id(battery_energy_wh_total);
      id(battery_energy_wh).publish_state(result);
      return result;


  - platform: template
    id: battery_energy_kwh
    name: "√ânergie batterie estim√©e (kWh)"
    unit_of_measurement: "kWh"
    device_class: energy
    state_class: total_increasing
    accuracy_decimals: 3
    icon: "mdi:battery-charging"
    lambda: |-
      float value = id(battery_energy_wh_total) / 1000.0;
      id(battery_energy_kwh).publish_state(value);
      return value;


# ==========================================================
# === TEXT SENSORS
# ==========================================================
text_sensor:
  - platform: lazy_limiter
    operation_mode:
      name: "${limiter_name} operation mode"

  - platform: dps
    protection_status:
      name: "DPS protection status"
    device_model:
      name: "DPS device model"

  # Affichage "phase" = mode Victron
  - platform: template
    id: charge_phase_text
    name: "Phase de charge batterie"

  - platform: template
    id: charge_phase_duration
    name: "Dur√©e charge active"

  # R√©cup√©ration du mode de charge Victron (source de v√©rit√©)
  - platform: homeassistant
    id: victron_mode
    name: "Victron charging mode"
    entity_id: sensor.smartsolar1_esp_charging_mode

  # MODIFICATION ‚Äî √âtat du soleil depuis HA ("above_horizon" / "below_horizon")

  - platform: homeassistant
    id: sun_state
    entity_id: sun.sun

# ==========================================================
# === SWITCHES
# ==========================================================
switch:

  - platform: template
    name: "‚ö†Ô∏è Forcer charge (Ignorer Victron)"
    id: force_charge_switch
    icon: "mdi:flash-alert"
    turn_on_action:
      - lambda: |-
          id(force_charge_mode) = true;
          ESP_LOGW("force", "‚ö†Ô∏è Mode Forc√© ACTIV√â ‚Äì DPS et R48 peuvent d√©marrer sans Victron !");
      - switch.turn_on: emerson_r48_ac_sw
      - delay: 2s
      - script.execute: start_sequence

    turn_off_action:
      - lambda: |-
          id(force_charge_mode) = false;
          ESP_LOGI("force", "‚úÖ Mode Forc√© d√©sactiv√© ‚Äì Retour au contr√¥le Victron");

  - platform: emerson_r48
    ac_sw:
      name: "R48 AC switch STOP"
      id: emerson_r48_ac_sw
      restore_mode: RESTORE_DEFAULT_OFF   # ou supprimer totalement la ligne
    dc_sw:
      name: "R48 DC switch STOP"
      id: emerson_r48_dc_sw
      restore_mode: ALWAYS_ON
    fan_sw:
      name: "R48 FAN switch MAX"
      id: emerson_r48_fan_sw
    led_sw:
      name: "R48 LED switch"

  - platform: lazy_limiter
    manual_mode:
      name: "${limiter_name} manual mode"
      restore_mode: RESTORE_DEFAULT_OFF
    emergency_power_off:
      name: "${limiter_name} emergency power off"

  - platform: dps
    output:
      id: dps_output_sw
      name: "DPS output"
    key_lock:
      id: dps_keylock_sw
      name: "DPS key lock"

  - platform: template
    name: "RAZ dur√©e charge active"
    icon: "mdi:timer-refresh"
    turn_on_action:
      - globals.set:
          id: phase_active_time
          value: "0"
      - logger.log: "üîÅ Dur√©e charge active remise √† z√©ro"
      - if:
          condition:
            lambda: |-
              std::string vm = id(victron_mode).state.c_str();
              for (auto &c : vm) c = tolower(c);
              return (vm == "bulk" || vm == "absorption" || vm == "float");
          then:
            - switch.turn_on: dps_output_sw
            - logger.log: "‚úÖ Victron OK ‚Üí DPS ON (apr√®s RAZ)"
          else:
            - logger.log: "‚õî Victron non pr√™t ‚Üí DPS OFF (apr√®s RAZ)"

  - platform: template
    name: "RAZ √©nergie batterie estim√©e"
    icon: "mdi:counter-reset"
    turn_on_action:
      - lambda: |-
          id(battery_energy_wh_total) = 0.0f;
          id(battery_energy_wh).publish_state(0.0f);
          id(battery_energy_kwh).publish_state(0.0f);
          ESP_LOGI("energy", "üîÑ √ânergie batterie estim√©e remise √† z√©ro");

# ==========================================================
# === NUMBERS (Emerson + Limiteur + DPS + Rendement)
# ==========================================================
number:
  # --- Emerson R48 ---
  - platform: emerson_r48
    output_voltage:
      name: "R48 Set output voltage"
      id: emerson_r48_output_voltage
    max_output_current:
      name: "R48 Max output current"
      id: emerson_r48_max_output_current
      unit_of_measurement: "%"
    max_input_current:
      name: "R48 Max input current"
      id: emerson_r48_max_input_current

  # --- Lazy Limiter ---
  - platform: lazy_limiter
    manual_power_demand:
      name: "${limiter_name} manual power demand"
    max_power_demand:
      name: "${limiter_name} max power demand"
      initial_value: 500
      restore_value: true

  # --- DPS5020 ---
  - platform: dps
    voltage_setting:
      id: voltage_setting
      name: "${limiter_name} voltage setting"
    current_setting:
      id: current_setting
      name: "${limiter_name} current setting"
      min_value: 0
      max_value: 19.5
      step: 0.1

  # --- Rendement DPS5020 ---
  - platform: template
    name: "Rendement DPS5020"
    id: dps_efficiency
    min_value: 70
    max_value: 100
    step: 1
    unit_of_measurement: "%"
    optimistic: true
    restore_value: true
    initial_value: 93

# ==========================================================
# === GLOBALS (√©nergie persistante + timers simples)
# ==========================================================
globals:

  - id: ha_fallback_active
    type: bool
    restore_value: no
    initial_value: "false"

  - id: last_victron_update_ts
    type: unsigned long
    restore_value: no
    initial_value: "0"

  - id: force_charge_mode
    type: bool
    restore_value: no
    initial_value: "false"

  - id: api_status
    type: bool
    restore_value: no
    initial_value: "false"

  - id: energy_wh
    type: float
    restore_value: yes
    initial_value: "0.0"

  - id: modbus_ready
    type: bool
    restore_value: no
    initial_value: "true"

  - id: battery_energy_wh_total
    type: float
    restore_value: yes
    initial_value: "0.0"

  # ‚è± Temps actif de charge (ne s'incr√©mente que si P > 10 W)
  - id: phase_active_time
    type: unsigned long
    restore_value: no
    initial_value: "0"

  # ‚è± Timestamp du dernier lancement de start_sequence (anti-doublon)
  - id: last_start_ts
    type: unsigned long
    restore_value: no
    initial_value: "0"

# ==========================================================
# === LOGIQUE VICRON + WATCHDOGS
# ==========================================================
interval:
  # üß© 1) Surveillance Modbus DPS5020
  - interval: 5s
    then:
      - lambda: |-
          static float last_voltage = 0.0f;
          if (id(dps_output_voltage).has_state()) {
            float v = id(dps_output_voltage).state;
            if (fabsf(v - last_voltage) > 0.05f) {
              id(modbus_ready) = true;
              last_voltage = v;
            }
          } else {
            id(modbus_ready) = false;
          }

# ‚ö° 2) Pilotage tension DPS + gestion Victron/R48/DPS (3s)
  - interval: 3s
    then:
      - lambda: |-
          if (!id(modbus_ready)) return;

          // --- D√©tection de panne Home Assistant / Victron ---
          bool victron_status_valid = id(victron_mode).has_state();
          
          // Si le statut Victron est "unknown", "unavailable", ou n'est pas parvenu depuis > 5 min
          if (!victron_status_valid || id(victron_mode).state == "unknown" || id(victron_mode).state == "unavailable") {
              // Mettre √† jour last_victron_update_ts uniquement si c'est la premi√®re fois qu'on d√©tecte l'erreur
              if (!id(ha_fallback_active)) {
                if (id(last_victron_update_ts) == 0) id(last_victron_update_ts) = millis();
              }
          } else {
              // Si le statut est valide, r√©initialiser le timestamp et d√©sactiver le fallback
              id(last_victron_update_ts) = millis();
              if (id(ha_fallback_active)) {
                  id(ha_fallback_active) = false;
                  ESP_LOGW("fallback", "‚úÖ Victron OK. Retour au contr√¥le normal.");
              }
          }

          // D√©tection de la condition de Fallback (plus de 5 minutes sans signal valide)
          if (!id(ha_fallback_active) && (millis() - id(last_victron_update_ts) > 300000)) { // 300000 ms = 5 minutes
              id(ha_fallback_active) = true;
              ESP_LOGE("fallback", "‚ö†Ô∏è HA/Victron hors ligne (>5 min). Bascule en mode S√âCURIT√â.");
          }
          
          // --- D√©termination du Mode d'Op√©ration ---
          
          std::string mode_raw;
          if (id(ha_fallback_active)) {
              mode_raw = "FALLBACK"; // Nouveau mode sp√©cial
          } else {
              mode_raw = id(victron_mode).state.c_str();
          }

          std::string mode = mode_raw;
          for (auto &c : mode) c = tolower(c);

          // ... (Le reste de votre logique, comme la gestion du last_mode_seen, doit √™tre ins√©r√© ici)
          
          // Le mode "FALLBACK" doit √™tre g√©r√© dans la s√©lection de la tension cible :
          
          // --- Choix tension cible
          const float V_BULK ¬† = 28.4f;
          const float V_ABS ¬† ¬†= 28.4f;
          const float V_FLOAT ¬†= 26.9f;
          const float V_IDLE ¬† = 27.1f;
          const float V_FALLBACK = 26.9f; // FLOAT de s√©curit√©

          // ... (Logique d'initialisation de v_init inchang√©e)

          float target_v = V_FLOAT;
          if (mode == "fallback") {
              target_v = V_FALLBACK;
              // Forcer le DPS ON en mode fallback
              if (!id(dps_output_sw).state) {
                id(dps_output_sw).turn_on();
                ESP_LOGW("fallback", "Activation DPS en mode FLOAT de s√©curit√©.");
              }
              // Limiter le courant √† 5A en mode fallback
              float current_limit = 5.0f; 
              if (id(current_setting).state > current_limit) {
                  id(current_setting).make_call().set_value(current_limit).perform();
                  ESP_LOGW("fallback", "Courant max limit√© √† %.1fA.", current_limit);
              }
          }
          else if (mode == "bulk") ¬† ¬† ¬† target_v = V_BULK;
          else if (mode == "absorption") target_v = V_ABS;
          else if (mode == "float") ¬† ¬† ¬†target_v = V_FLOAT;
          else if (mode == "off" || mode == "idle" || mode == "night" || mode == "fault") target_v = V_IDLE;

          // ... (Le reste du lambda pour la rampe de tension (slew), l'activation/d√©sactivation du DPS, et les calculs d'√©nergie reste le m√™me)

          // Assurez-vous d'adapter la ligne qui met √† jour la phase de charge :
          char buf[64];
          if (id(ha_fallback_active)) {
              snprintf(buf, sizeof(buf), "Victron : FALLBACK (HA DOWN)");
          } else {
              snprintf(buf, sizeof(buf), "Victron : %s", mode_raw.c_str());
          }
          id(charge_phase_text).publish_state(buf);
          
          // ... (Fin du lambda)

# üîå 3) Watchdog Modbus DPS5020 (Am√©lior√© : se d√©clenche seulement si la charge est active)
  - interval: 10s
    then:
      - lambda: |-
          // 1. D√©termine si le DPS est cens√© √™tre actif et faire varier ses valeurs.
          // On v√©rifie la consigne de courant (celle pilot√©e par le lazy_limiter), pas le courant de sortie r√©el, 
          // car la consigne est la demande de l'ESP.
          bool dps_should_be_active = 
              id(dps_output_sw).state &&
              id(current_setting).has_state() && 
              id(current_setting).state > 0.5f; 
          
          // D√©claration des statiques pour la d√©tection de blocage
          static unsigned long last_dps_change = millis();
          static float lv=0, li=0, lp=0;
          bool data_changed = false;
          
          // 2. V√©rification des changements de donn√©es Modbus
          if (id(dps_output_voltage).has_state() && fabsf(id(dps_output_voltage).state-lv) > 0.01f) { 
              lv = id(dps_output_voltage).state; 
              data_changed = true; 
          }
          if (id(dps_output_current).has_state() && fabsf(id(dps_output_current).state-li) > 0.02f) { 
              li = id(dps_output_current).state; 
              data_changed = true; 
          }
          if (id(dps_output_power).has_state() && fabsf(id(dps_output_power).state-lp) > 0.5f) { 
              lp = id(dps_output_power).state; 
              data_changed = true; 
          }
          
          if (data_changed) {
              last_dps_change = millis();
              // Les donn√©es bougent, tout va bien.
              return; 
          }

          // 3. Logique de d√©clenchement du Watchdog
          unsigned long time_since_last_change = millis() - last_dps_change;

          if (dps_should_be_active && time_since_last_change > 15000) { 
              // Le DPS est cens√© charger (consigne > 0.5A) mais les donn√©es sont fig√©es depuis 15s.
              ESP_LOGW("watchdog", "üßØ DPS Modbus bloqu√© (>15s) malgr√© charge active ‚Üí reset Modbus.");
              id(modbus_ready) = false;
              // On utilise un script temporis√© pour r√©activer modbus_ready apr√®s un court d√©lai.
              // Dans ce cas, nous devons utiliser un script s√©par√© si nous voulons un d√©lai non bloquant.
              // Mais pour une simple r√©activation de Modbus, un court d√©lai de 1s suffit :
              id(modbus_ready) = true;
          } else if (!dps_should_be_active && time_since_last_change > 3600000) {
              // Si le DPS est au repos, on logge seulement une fois par heure (3600s) pour ne pas polluer les logs.
              // De plus, on r√©initialise le timer de changement de donn√©es
              // pour √©viter un d√©clenchement imm√©diat lorsque la charge reprend.
              ESP_LOGD("watchdog", "Modbus au repos (aucune activit√© Modbus depuis >1h).");
              last_dps_change = millis();
          }

  # üì° 4) Watchdog Wi-Fi / API
  - interval: 60s
    then:
      - if:
          condition:
            lambda: |-
              static unsigned long last_seen = millis();
              if (id(api_connected).state)
                last_seen = millis();
              return (millis() - last_seen > 600000);
          then:
            - logger.log: "‚ùå API absente >10 min ‚Üí reboot ESP"
            - button.press: restart_esp

  # üîÅ 5) Watchdog CAN R48 (corrig√© : ignore 15s apr√®s boot)
  - interval: 2s
    then:
      - lambda: |-
          if (millis() < 15000) return;
          if (!id(dps_output_sw).state) return;
          if (!id(emerson_r48_dc_sw).state) return;

          static uint32_t last_seen = millis();
          if (id(r48_output_current).has_state() && id(r48_output_current).state > 0.05f) {
            last_seen = millis();
            return;
          }

          static uint32_t last_reset = 0;
          uint32_t now = millis();
          if ((now - last_seen > 5000) && (now - last_reset > 30000)) {
            ESP_LOGI("watchdog", "üîÅ CAN R48 inactif ‚Üí reset DC");
            last_reset = now;
            id(r48_dc_reset_short).execute();
          }

  # ‚öôÔ∏è 6) Watchdog charge bloqu√©e
  - interval: 30s
    then:
      - if:
          condition:
            lambda: |-
              static unsigned long last_power = millis();
              if (id(charger_active).state && id(dps_output_power).state > 20.0f)
                last_power = millis();
              return (id(charger_active).state && millis() - last_power > 60000);
          then:
            - logger.log: "‚ö†Ô∏è Charge bloqu√©e sans puissance ‚Üí restart DPS"
            - switch.turn_off: dps_output_sw
            - delay: 1s
            - if:
                condition:
                  lambda: |-
                    std::string vm = id(victron_mode).state.c_str();
                    for (auto &c : vm) c = tolower(c);
                    return (vm == "bulk" || vm == "absorption" || vm == "float");
                then:
                  - switch.turn_on: dps_output_sw
                  - logger.log: "‚úÖ Victron OK ‚Üí DPS relanc√©"
                else:
                  - logger.log: "‚õî Victron non pr√™t ‚Üí DPS reste OFF"

  # ‚ö° 7) Watchdog surtension batterie (corrig√©)
  - interval: 2s
    then:
      - lambda: |-
          static unsigned long overvolt_start = 0;
          if (!id(dps_output_sw).state) { overvolt_start = 0; return; }

          const float v = id(dps_output_voltage).state;
          const float V_WARN   = 29.0f;
          const float V_CUTOFF = 29.2f;
          const uint32_t DELAY = 3000;

          if (v > V_WARN) {
            if (overvolt_start == 0) {
              ESP_LOGI("watchdog", "‚ö†Ô∏è Surtension d√©tect√©e (%.2f V)", v);
              overvolt_start = millis();
            }
          } else {
            overvolt_start = 0;
          }

          if (overvolt_start > 0 && v > V_CUTOFF && millis() - overvolt_start > DELAY) {
            ESP_LOGW("watchdog", "üõë Coupure surtension batterie !");
            id(dps_output_sw).turn_off();
            id(charge_phase_text).publish_state("‚ö†Ô∏è Coupure surtension batterie !");
          }

  # üå°Ô∏è 8) Watchdog temp√©rature Emerson
  - interval: 5s
    then:
      - lambda: |-
          if (!id(r48_output_temp).has_state()) return;
          float t = id(r48_output_temp).state;
          if (!(t > -20.0f && t < 90.0f)) return;

          static bool fan_forced = false;
          if (t >= 55.0f && t < 70.0f)
            ESP_LOGI("watchdog", "üå°Ô∏è Temp√©rature R48 √©lev√©e : %.1f¬∞C", t);
          if (t >= 60.0f && !fan_forced) {
            id(emerson_r48_fan_sw).turn_on();
            fan_forced = true;
          }
          if (t >= 70.0f) {
            ESP_LOGW("watchdog", "üî• SURCHAUFFE ‚Üí DC OFF + DPS OFF");
            id(emerson_r48_dc_sw).turn_off();
            id(dps_output_sw).turn_off();
            id(charge_phase_text).publish_state("‚ö†Ô∏è Coupure surchauffe Emerson !");
          }
          if (t <= 50.0f && fan_forced) {
            id(emerson_r48_fan_sw).turn_off();
            fan_forced = false;
          }

  # üßØ 9) DC OFF si DPS OFF
  - interval: 2s
    then:
      - lambda: |-
          static bool dc_cut = false;
          if (!id(dps_output_sw).state && id(emerson_r48_dc_sw).state && !dc_cut) {
            id(emerson_r48_dc_sw).turn_off();
            dc_cut = true;
          }
          if (id(dps_output_sw).state && !id(emerson_r48_dc_sw).state && dc_cut) {
            id(dc_rearm_after_dps_on).execute();
            dc_cut = false;
          }

  # üîã 10) Watchdog surintensit√© DPS5020
  - interval: 1s
    then:
      - lambda: |-
          static bool overload = false;
          static unsigned long start = 0, recover = 0;
          float I = id(dps_output_current).state;

          if (I >= 20.0f && I < 22.0f && !overload)
            ESP_LOGI("watchdog", "‚ö†Ô∏è Courant √©lev√© : %.2f A", I);

          if (I >= 22.0f && !overload) {
            if (start == 0) start = millis();
            if (millis() - start > 2000) {
              ESP_LOGW("watchdog", "üõë SURINTENSIT√â ‚Üí DPS OFF");
              id(dps_output_sw).turn_off();
              id(charge_phase_text).publish_state("‚ö†Ô∏è Coupure surintensit√© DPS !");
              overload = true;
            }
          } else start = 0;

          if (overload && I <= 5.0f) {
            if (recover == 0) recover = millis();
            if (millis() - recover > 3000) {
              std::string vm = id(victron_mode).state.c_str();
              for (auto &c : vm) c = tolower(c);
              bool ok = (vm == "bulk" || vm == "absorption" || vm == "float");
              if (ok) {
                ESP_LOGI("watchdog", "‚úÖ Reprise DPS, courant OK");
                id(dps_output_sw).turn_on();
              }
              overload = false;
              recover = 0;
            }
          } else recover = 0;

  # üßØ 11) Watchdog d√©marrage DPS √©chou√©
  - interval: 10s
    then:
      - lambda: |-
          static int retry = 0;
          static int freezes = 0;
          std::string vm = id(victron_mode).state.c_str();
          for (auto &c : vm) c = tolower(c);
          bool victron_ok = (vm == "bulk" || vm == "absorption" || vm == "float");

          if (victron_ok && !id(dps_output_sw).state && !id(force_charge_mode)) {
            retry++;
            ESP_LOGW("watchdog", "‚ö† DPS non actif (tentative %d)", retry);
          } else retry = 0;

          if (retry > 3) {
            freezes++;
            ESP_LOGE("watchdog", "üßØ DPS fig√© ‚Üí reset Modbus/DC (cycle %d)", freezes);
            id(dps_output_sw).turn_off();
            id(emerson_r48_dc_sw).turn_off();
            id(modbus_ready) = false;
            retry = 0;
          }

          if (freezes >= 3) {
            ESP_LOGE("watchdog", "‚õî Abandon ‚Üí Intervention humaine requise !");
            id(force_charge_mode) = false;
            id(emerson_r48_ac_sw).turn_off();
            id(dps_output_sw).turn_off();
            freezes = 0;
          }

          if (id(dps_output_sw).state) freezes = 0;
