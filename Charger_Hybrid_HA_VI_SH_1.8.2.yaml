# ==========================================================
#   PROJET : Chargeur hybride LiFePO‚ÇÑ 24V 300Ah (Optimis√© Victron)
#   Version : 1.8.2 - 2025-11-18
#
#   CHANGELOG / VARIANTE A (bas√©e sur 1.8.0) :
#
#   üîß Correctifs Victron :
#     - Comparaison directe des modes Victron ("bulk", "absorption", "float")
#       au lieu de "${victron_valid_modes}" (fiabilit√© + compatibilit√© HA)
#
#   ‚ö° Emerson R48 :
#     - Restauration des unit√©s "%" pour max_output_current et max_input_current
#     - Correction coh√©rente des types sensor + number
#
#   üß∞ Modbus / Fiabilit√© :
#     - Conservation des correctifs CRC Modbus
#     - S√©curisation du start_sequence (has_state)
#     - Am√©lioration des watchdogs (surintensit√©, freeze, red√©marrage soft)
#
#   üîã √ânergie :
#     - Ajout compteur *r√©el* c√¥t√© batterie (battery_energy_wh_total)
#     - Ajout sensors HA pour affichage : battery_energy_wh / battery_energy_kwh
#     - Ajout reset d√©di√© : "RAZ √©nergie batterie r√©elle"
#     - Correction state_class + device_class (compatible HA Energy Dashboard)
#
#   üßπ Nettoyage :
#     - Clarification de la structure YAML
#     - (Optionnel recommand√©) Suppression progressive des anciens compteurs
#       estim√©s DPS (dps_energy_wh / dps_energy_kwh) pour √©viter les doublons
#
# ==========================================================

substitutions:
  # ===== G√©n√©ral =====
  device_description: "Chargeur 1.8.2 LiFePO4 24V 300Ah via DPS5020 (pilot√© Victron)"
  limiter_name: limiter
  tx_pin: GPIO17
  rx_pin: GPIO16
  ota_pswd: !secret ota_pswd
  ap_pwd: !secret ota_pswd
  adress_ip: !secret ip_R48dps
  gateway_ip: !secret ip_gateway
  dns_ip: !secret ip_dns

  # ===== SPI / CAN =====
  spi_clk_pin: GPIO18
  spi_mosi_pin: GPIO23
  spi_miso_pin: GPIO19
  can_cs_pin: GPIO5
  can_id: "0x0607FF83"
  can_bit_rate: "125kbps"
  can_clock: "8MHz"

  # ===== UART / Modbus =====
  uart_baud_rate: "9600"
  modbus_send_wait_time: "50ms"

  # ===== Lazy Limiter =====
  power_sensor_inactivity_timeout: "20s"
  min_power_demand: "50"
  max_power_demand: "500"
  limiter_buffer: "30"
  limiter_update_interval: "3s"

  # ===== Globals =====
  modbus_ready_delay: "200"
  force_charge_mode_default: "false"
  api_status_default: "false"
  ha_fallback_active_default: "false"
  last_error_default: '"Aucune erreur"'
  energy_wh_default: "0.0"
  battery_energy_wh_total_default: "0.0"
  phase_active_time_default: "0"

  # ===== Scripts =====
  start_sequence_delay: "2s"
  victron_valid_modes: "bulk,absorption,float"
  dps_voltage_default: "26.9"
  dps_current_default: "5.0"
  dps_max_current: "20.0"
  dps_max_power: "500.0"

  # ===== Binary Sensors =====
  r48_ac_voltage_min: "185"
  r48_ac_voltage_max: "215"
  r48_ac_present_delay_on: "3s"
  r48_ac_present_delay_off: "3s"

  # ===== Sensors =====
  dps_efficiency_default: "93"
  dps_efficiency_min: "70"
  dps_efficiency_max: "100"
  dps_efficiency_step: "1"

  # ===== Victron Modes =====
  victron_voltage_bulk: "28.4"
  victron_voltage_absorption: "28.4"
  victron_voltage_float: "26.9"
  victron_voltage_idle: "27.1"
  victron_fallback_voltage_threshold: "28.0"
  victron_fallback_current_limit: "5.0"

  # ===== Watchdogs =====
  modbus_freeze_timeout: "45000"
  api_reboot_timeout: "600000"
  can_reset_timeout: "30000"
  charge_blocked_timeout: "60000"
  overtension_threshold: "29.0"
  overtension_critical_threshold: "29.2"
  overtension_critical_delay: "3000"
  temperature_fan_on: "60.0"
  temperature_critical: "70.0"
  temperature_fan_off: "50.0"

  # ===== Intervalles =====
  watchdog_modbus_interval: "5s"
  watchdog_victron_interval: "3s"
  watchdog_dps_interval: "10s"
  watchdog_api_interval: "60s"
  watchdog_can_interval: "2s"
  watchdog_charge_blocked_interval: "30s"
  watchdog_overtension_interval: "2s"
  watchdog_temperature_interval: "5s"

esphome:
  name: charger-hybrid
  friendly_name: "Chargeur Hybride Emerson + DPS5020 (Victron)"
  min_version: 2024.6.0
  comment: "Version 1.8.2 (fix CRC Modbus + substitutions + unit√©s % + Victron OK)"
  on_boot:
    priority: -100
    then:
      - delay: 2s
      - logger.log: "‚ö° ESP d√©marr√© ‚Äì AC R48 volontairement √©teint (s√©curit√©)"
      - if:
          condition:
            lambda: |-
              std::string vm = id(victron_mode).state.c_str();
              for (auto &c : vm) c = tolower(c);
              bool victron_ok = (vm == "bulk" || vm == "absorption" || vm == "float");
              if (id(sun_down).state && !victron_ok && !id(force_charge_mode)) return false;
              return (millis() - id(last_start_ts)) > 15000;
          then:
            - script.execute: start_sequence
            - lambda: "id(last_start_ts) = millis();"

esp32:
  board: esp32dev
  framework:
    type: arduino

# ==========================================================
# === LOGS
# ==========================================================
logger:
  level: INFO
  logs:
    emerson_r48: WARN
    mcp2515: INFO
    lazy_limiter: INFO
    limiter: INFO
    component: INFO
    dps: INFO
    script: INFO
    watchdog: INFO

# ==========================================================
# === API & OTA
# ==========================================================
api:
  on_client_connected:
    - lambda: "id(api_status)=true; id(api_connected).publish_state(true);"
  on_client_disconnected:
    - lambda: "id(api_status)=false; id(api_connected).publish_state(false);"

ota:
  platform: esphome

# ==========================================================
# === WIFI
# ==========================================================
wifi:
  networks:
    - ssid: !secret wifi_ssid
      password: !secret wifi_password
      priority: 0
    - ssid: !secret wifi_ssid2
      password: !secret wifi_password2
      priority: 1
  manual_ip:
    static_ip: ${adress_ip}
    gateway: ${gateway_ip}
    subnet: 255.255.255.0
    dns1: ${dns_ip}
  ap:
    password: !secret ota_pswd

web_server:

# ==========================================================
# === EXTERNAL COMPONENTS
# ==========================================================
external_components:
  - source:
      type: git
      url: https://github.com/jon7119/esphomeemerson-vertiv-r48
      ref: main
    refresh: 0s
  - source: github://syssi/esphome-dps@main
    refresh: 0s

# ==========================================================
# === SPI / CAN
# ==========================================================
spi:
  id: shared_spi
  clk_pin: ${spi_clk_pin}
  mosi_pin: ${spi_mosi_pin}
  miso_pin: ${spi_miso_pin}

canbus:
  - platform: mcp2515
    id: can
    spi_id: shared_spi
    use_extended_id: true
    cs_pin: ${can_cs_pin}
    can_id: ${can_id}
    bit_rate: ${can_bit_rate}
    clock: ${can_clock}

emerson_r48:
  canbus_id: can
  update_interval: 3s

# ==========================================================
# === UART / MODBUS
# ==========================================================
uart:
  id: uart_0
  baud_rate: ${uart_baud_rate}
  tx_pin: ${tx_pin}
  rx_pin: ${rx_pin}

modbus:
  id: modbus0
  uart_id: uart_0
  send_wait_time: ${modbus_send_wait_time}

dps:
  id: dps0
  modbus_id: modbus0
  update_interval: 5s

# ==========================================================
# === LAZY LIMITER (composant)
# ==========================================================
lazy_limiter:
  power_id: powermeter
  power_sensor_inactivity_timeout: ${power_sensor_inactivity_timeout}
  power_demand_calculation: NEGATIVE_MEASUREMENTS_REQUIRED
  min_power_demand: ${min_power_demand}
  max_power_demand: ${max_power_demand}
  buffer: ${limiter_buffer}
  update_interval: ${limiter_update_interval}

# ==========================================================
# === BUTTONS
# ==========================================================
button:
  - platform: restart
    name: "Restart ESP"
    id: restart_esp

# ==========================================================
# === GLOBALS
# ==========================================================
globals:
  - id: last_modbus_cmd
    type: unsigned long
    initial_value: "0"
  - id: modbus_ready
    type: bool
    initial_value: "true"
  - id: force_charge_mode
    type: bool
    initial_value: "${force_charge_mode_default}"
  - id: api_status
    type: bool
    initial_value: "${api_status_default}"
  - id: ha_fallback_active
    type: bool
    initial_value: "${ha_fallback_active_default}"
  - id: last_victron_update_ts
    type: unsigned long
    initial_value: "0"
  - id: last_start_ts
    type: unsigned long
    initial_value: "0"
  - id: last_error
    type: std::string
    initial_value: "${last_error_default}"
  - id: energy_wh
    type: float
    restore_value: yes
    initial_value: "${energy_wh_default}"
  - id: battery_energy_wh_total
    type: float
    restore_value: yes
    initial_value: "${battery_energy_wh_total_default}"
  - id: phase_active_time
    type: unsigned long
    initial_value: "${phase_active_time_default}"

# ==========================================================
# === SCRIPTS
# ==========================================================
script:
  # --- S√©quence de d√©marrage ---
  - id: start_sequence
    mode: queued
    then:
      - lambda: |-
          std::string vm = id(victron_mode).state.c_str();
          for (auto &c : vm) c = tolower(c);
          bool victron_ok = (vm == "bulk" || vm == "absorption" || vm == "float");
          if (id(sun_down).state && !victron_ok && !id(force_charge_mode)) {
            ESP_LOGW("start", "üåô Nuit + Victron OFF ‚Üí abort");
            return;
          }
      - switch.turn_on: emerson_r48_ac_sw
      - delay: ${start_sequence_delay}
      - switch.turn_off: emerson_r48_ac_sw
      - delay: 2s
      - wait_until:
          condition:
            lambda: "return id(r48_output_voltage).has_state();"
          timeout: 7s
      - number.set:
          id: emerson_r48_output_voltage
          value: 48.0
      - number.set:
          id: emerson_r48_max_output_current
          value: 30
      - number.set:
          id: emerson_r48_max_input_current
          value: 5
      - switch.turn_off: emerson_r48_dc_sw
      - delay: 3s
      - lambda: |-
          if (!id(modbus_ready)) return;
          unsigned long now = millis();
          if (now - id(last_modbus_cmd) >= ${modbus_ready_delay}) {
            id(voltage_setting).make_call().set_value(${dps_voltage_default}).perform();
            id(last_modbus_cmd) = now;
          }
      - lambda: |-
          std::string vm = id(victron_mode).state.c_str();
          for (auto &c : vm) c = tolower(c);
          bool victron_ok = (vm == "bulk" || vm == "absorption" || vm == "float");
          if (victron_ok) {
            id(dps_output_sw).turn_on();
          }

  # --- Transition Victron OFF ‚Üí ON ---
  - id: seq_victron_ok
    mode: restart
    then:
      - lambda: |-
          std::string vm = id(victron_mode).state.c_str();
          for (auto &c : vm) c = tolower(c);
          bool victron_ok = (vm == "bulk" || vm == "absorption" || vm == "float");
          if (id(sun_down).state && !victron_ok && !id(force_charge_mode)) {
            ESP_LOGW("seq", "üåô Nuit : pas de relance AC");
            return;
          }
      - switch.turn_on: emerson_r48_ac_sw
      - delay: 2s
      - script.execute: start_sequence

  # --- R√©initialisation Modbus (non-bloquante) ---
  - id: reset_modbus_connection
    mode: restart
    then:
      - lambda: |-
          id(modbus_ready) = false;
          ESP_LOGW("watchdog", "üîÑ R√©initialisation Modbus‚Ä¶");
      - delay: 2s
      - lambda: |-
          id(modbus_ready) = true;
          id(dps0).update();
          ESP_LOGI("watchdog", "‚úÖ Modbus OK");

  # --- Rearm DC apr√®s DPS ON ---
  - id: dc_rearm_after_dps_on
    mode: restart
    then:
      - delay: 3s
      - switch.turn_on: emerson_r48_dc_sw

  # --- Reset court DC R48 ---
  - id: r48_dc_reset_short
    mode: restart
    then:
      - switch.turn_off: emerson_r48_dc_sw
      - delay: 1s
      - switch.turn_on: emerson_r48_dc_sw

  # --- Gestion erreur critique ---
  - id: handle_critical_error
    parameters:
      error_msg: string
    then:
      - logger.log:
          format: "‚õî ERREUR CRITIQUE : %s"
          args: [error_msg.c_str()]
      - switch.turn_off: dps_output_sw
      - switch.turn_off: emerson_r48_dc_sw
      - switch.turn_off: emerson_r48_ac_sw
      - lambda: |-
          id(charge_phase_text).publish_state(error_msg);
          id(last_error) = error_msg;
          id(last_errors).update();

# ==========================================================
# === BINARY SENSORS
# ==========================================================
binary_sensor:
  - platform: template
    id: api_connected
    name: "API connect√©e"
    device_class: connectivity
    lambda: "return id(api_status);"

  - platform: status
    name: "ESP Controller Status"

  - platform: dps
    output:
      id: dps_output
    key_lock:
      id: dps_key_lock
    constant_current_mode:
      name: "DPS constant current mode"

  - platform: template
    id: charger_active
    name: "Chargeur automatique actif"
    device_class: power
    lambda: "return id(current_setting).state>0.5f && id(dps_output_sw).state;"

  - platform: template
    id: r48_ac_present
    name: "R48 AC pr√©sent"
    device_class: power
    lambda: |-
      static bool ac=false;
      if(!id(r48_ac_voltage).has_state())return false;
      float v=id(r48_ac_voltage).state;
      if(!ac && v>${r48_ac_voltage_max})ac=true;
      if(ac && v<${r48_ac_voltage_min})ac=false;
      return ac;
    filters:
      - delayed_on: ${r48_ac_present_delay_on}
      - delayed_off: ${r48_ac_present_delay_off}
    on_press:
      then:
        - lambda: |-
            if(millis()-id(last_start_ts)<12000)return;
            std::string vm=id(victron_mode).state.c_str();
            for(auto &c:vm)c=tolower(c);
            bool victron_ok=(vm=="bulk" || vm=="absorption" || vm=="float");
            if(!victron_ok)return;
            id(last_start_ts)=millis();
        - script.execute: start_sequence

  - platform: template
    id: sun_down
    name: "Soleil couch√©"
    lambda: "return id(sun_state).has_state() && id(sun_state).state==\"below_horizon\";"

# ==========================================================
# === SENSORS (Emerson + Limiteur + DPS + Energies)
# ==========================================================
sensor:
  # ------------------- EMERSON R48 -------------------
  - platform: emerson_r48
    output_voltage:
      id: r48_output_voltage
      name: "R48 Output voltage"
    output_current:
      id: r48_output_current
      name: "R48 Output current"
    output_temp:
      id: r48_output_temp
      name: "R48 Temperature"
    input_voltage:
      id: r48_ac_voltage
      name: "R48 AC Voltage"
    max_output_current:
      name: "R48 DC max current"
      unit_of_measurement: "%"

  # ------------------- POWER EMERSON -------------------
  - platform: template
    id: outpower
    name: "Puissance Emerson (entr√©e DPS)"
    unit_of_measurement: "W"
    device_class: power
    update_interval: 6s
    accuracy_decimals: 1
    lambda: |-
      if(!id(dps_output_sw).state)return 0;
      if(!id(r48_output_current).has_state()||!id(r48_output_voltage).has_state())return 0;
      float i=id(r48_output_current).state;
      if(i<0.2)return 0;
      return i*id(r48_output_voltage).state;

  # ------------------- SMARTMETER -------------------
  - platform: homeassistant
    internal: true
    id: powermeter
    name: "DPS smartmeter instantaneous power"
    entity_id: sensor.cptlinkyshe_power
    filters:
      - multiply: -1
      - throttle_average: 1s
      - lambda: |-
          static bool active=false;
          static unsigned long on_ts=0,off_ts=0;
          if(x>=30){
            if(!on_ts)on_ts=millis();
            if(!active && millis()-on_ts>3000)active=true;
          }else on_ts=0;
          if(x<=10){
            if(!off_ts)off_ts=millis();
            if(active && millis()-off_ts>5000)active=false;
          }else off_ts=0;
          if(!active)x=0;
          return round(x*100)/100;

  # ------------------- LAZY LIMITER -------------------
  - platform: lazy_limiter
    power_demand:
      name: "${limiter_name} power demand"
      on_value:
        - lambda: |-
            std::string vm=id(victron_mode).state.c_str();
            for(auto &c:vm)c=tolower(c);
            bool victron_ok=(vm=="bulk" || vm=="absorption" || vm=="float");
            if(!victron_ok || !id(dps_output_sw).state){
              id(current_setting).make_call().set_value(0).perform();
              return;
            }
            if(!id(modbus_ready))return;
            unsigned long now=millis();
            if(now-id(last_modbus_cmd)<80)return;
            float v=id(dps_output_voltage).state;
            if(v<1)v=${dps_voltage_default};
            float pd=x; if(pd<0)pd=0; if(pd>${dps_max_power})pd=${dps_max_power};
            float a=pd/v; if(a>${dps_max_current})a=${dps_max_current};
            id(current_setting).make_call().set_value(a).perform();
            id(last_modbus_cmd)=now;

  # ------------------- DPS5020 MEASURES -------------------
  - platform: dps
    output_voltage:
      id: dps_output_voltage
      name: "DPS output voltage"
    output_current:
      id: dps_output_current
      name: "DPS output current"
    output_power:
      id: dps_output_power
      name: "DPS output power"
    input_voltage:
      name: "DPS input voltage"
    voltage_setting:
      id: dps_voltage_sensor
      name: "DPS voltage setting"
    current_setting:
      id: dps_current_sensor
      name: "DPS current setting"
    firmware_version:
      name: "DPS firmware version"

  # ------------------- ENERGY COUNTERS -------------------
  - platform: template
    id: dps_energy_wh
    name: "√ânergie autoconsomm√©e batterie (Wh)"
    unit_of_measurement: "Wh"

  - platform: template
    id: dps_energy_kwh
    name: "√ânergie autoconsomm√©e batterie (kWh)"
    unit_of_measurement: "kWh"
    lambda: "return id(dps_energy_wh).state/1000.0;"

  - platform: template
    id: battery_power_est
    name: "Puissance batterie estim√©e"
    unit_of_measurement: "W"
    update_interval: 6s
    lambda: |-
      float eff=id(dps_efficiency).state/100.0;
      if(!id(r48_output_current).has_state())return 0;
      if(!id(r48_output_voltage).has_state())return 0;
      if(!id(dps_output_sw).state)return 0;
      float p=id(r48_output_current).state*id(r48_output_voltage).state;
      return p*eff;
# ------------------- √âNERGIE R√âELLE C√îT√â BATTERIE (affichage HA) -------------------
  - platform: template
    id: battery_energy_wh
    name: "√ânergie batterie r√©elle (Wh)"
    unit_of_measurement: "Wh"
    state_class: total_increasing
    device_class: energy
    lambda: "return id(battery_energy_wh_total);"

  - platform: template
    id: battery_energy_kwh
    name: "√ânergie batterie r√©elle (kWh)"
    unit_of_measurement: "kWh"
    state_class: total_increasing
    device_class: energy
    lambda: "return id(battery_energy_wh_total) / 1000.0f;"
# ==========================================================
# === TEXT SENSORS
# ==========================================================
text_sensor:
  - platform: lazy_limiter
    operation_mode:
      name: "${limiter_name} operation mode"

  - platform: dps
    protection_status:
      name: "DPS protection status"
    device_model:
      name: "DPS device model"

  - platform: template
    id: charge_phase_text
    name: "Phase de charge batterie"

  - platform: template
    id: charge_phase_duration
    name: "Dur√©e charge active"

  - platform: homeassistant
    id: victron_mode
    name: "Victron charging mode"
    entity_id: sensor.smartsolar1_esp_charging_mode

  - platform: homeassistant
    id: sun_state
    entity_id: sun.sun

  - platform: template
    id: last_errors
    name: "Derni√®re erreur critique"
    lambda: "return id(last_error);"

# ==========================================================
# === SWITCHES
# ==========================================================
switch:
  - platform: template
    id: limiter_emergency_power_off
    name: "${limiter_name} emergency hard power off"
    icon: mdi:alert-octagon
    turn_on_action:
      - lambda: |-
          ESP_LOGE("limiter", "üõë EMERGENCY HARD POWER OFF d√©clench√© !");
          id(last_error) = "üõë Emergency hard power OFF";
          id(charge_phase_text).publish_state("üõë Emergency HARD OFF");
      - switch.turn_off: dps_output_sw
      - switch.turn_off: emerson_r48_dc_sw
      - switch.turn_off: emerson_r48_ac_sw
      - if:
          condition:
            lambda: "return id(modbus_ready);"
          then:
            - lambda: |-
                id(current_setting).make_call().set_value(0).perform();
                id(voltage_setting).make_call().set_value(${dps_voltage_default}).perform();
      - lambda: "id(force_charge_mode) = false;"
    turn_off_action:
      - lambda: |-
          ESP_LOGW("limiter", "‚ö†Ô∏è Emergency OFF rel√¢ch√© ‚Üí retour mode normal");
          id(charge_phase_text).publish_state("Mode normal");
      - delay: 1s
      - lambda: "id(last_error) = \"Aucune erreur\";"
      - script.execute: start_sequence

  - platform: template
    id: force_charge_switch
    name: "‚ö†Ô∏è Forcer charge (Ignorer Victron)"
    icon: mdi:flash-alert
    turn_on_action:
      - lambda: |-
          id(force_charge_mode)=true;
          id(handle_critical_error).execute("‚ö†Ô∏è Mode forc√© activ√©");
      - switch.turn_on: emerson_r48_ac_sw
      - delay: 2s
      - script.execute: start_sequence
    turn_off_action:
      - lambda: "id(force_charge_mode)=false;"

  - platform: emerson_r48
    ac_sw:
      id: emerson_r48_ac_sw
      name: "R48 AC switch STOP"
      restore_mode: RESTORE_DEFAULT_OFF
    dc_sw:
      id: emerson_r48_dc_sw
      name: "R48 DC switch STOP"
      restore_mode: ALWAYS_ON
    fan_sw:
      id: emerson_r48_fan_sw
      name: "R48 FAN MAX"
    led_sw:
      name: "R48 LED switch"

  - platform: lazy_limiter
    manual_mode:
      name: "${limiter_name} manual mode"

  - platform: dps
    output:
      id: dps_output_sw
      name: "DPS output"
    key_lock:
      id: dps_keylock_sw
      name: "DPS key lock"

  - platform: template
    name: "RAZ dur√©e charge active"
    icon: mdi:timer-refresh
    turn_on_action:
      - globals.set: {id: phase_active_time, value: "0"}
      
  - platform: template
    name: "RAZ √©nergie batterie r√©elle"
    icon: mdi:counter-reset
    turn_on_action:
      - lambda: |-
          id(battery_energy_wh_total) = 0;
          id(battery_energy_wh).publish_state(0);
          id(battery_energy_kwh).publish_state(0);

# ==========================================================
# === NUMBERS
# ==========================================================
number:
  - platform: emerson_r48
    output_voltage:
      id: emerson_r48_output_voltage
      name: "R48 Set output voltage"
    max_output_current:
      id: emerson_r48_max_output_current
      name: "R48 Max output current"
      unit_of_measurement: "%"
    max_input_current:
      id: emerson_r48_max_input_current
      name: "R48 Max input current"
      unit_of_measurement: "%"

  - platform: lazy_limiter
    manual_power_demand:
      name: "${limiter_name} manual power demand"
    max_power_demand:
      name: "${limiter_name} max power demand"
      initial_value: ${max_power_demand}
      restore_value: true

  - platform: dps
    voltage_setting:
      id: voltage_setting
      name: "DPS voltage setting"
    current_setting:
      id: current_setting
      name: "DPS current setting"
      min_value: 0
      max_value: ${dps_max_current}
      step: 0.1

  - platform: template
    id: dps_efficiency
    name: "Rendement DPS5020"
    min_value: ${dps_efficiency_min}
    max_value: ${dps_efficiency_max}
    step: ${dps_efficiency_step}
    unit_of_measurement: "%"
    optimistic: true
    restore_value: true
    initial_value: ${dps_efficiency_default}

# ==========================================================
# === WATCHDOGS
# ==========================================================
interval:
  # ------------------- WATCHDOG MODBUS -------------------
  - interval: ${watchdog_modbus_interval}
    then:
      - lambda: |-
          static float last_v = 0;
          if (id(dps_output_voltage).has_state()) {
            float v = id(dps_output_voltage).state;
            if (fabsf(v - last_v) > 0.05f) {
              id(modbus_ready) = true;
              last_v = v;
            }
          } else {
            id(modbus_ready) = false;
          }

  # ------------------- PILOTAGE VICRON + FALLBACK -------------------
  - interval: ${watchdog_victron_interval}
    then:
      - lambda: |-
          if (!id(modbus_ready)) return;

          // --- 1) V√©rification validit√© du mode Victron
          bool valid = id(victron_mode).has_state() &&
                       id(victron_mode).state != "unknown" &&
                       id(victron_mode).state != "unavailable";

          if (valid) {
            id(last_victron_update_ts) = millis();
          }

          // --- 2) Activation fallback si HA down > 5 minutes
          if (millis() - id(last_victron_update_ts) > 300000) {
            if (!id(ha_fallback_active)) {
              id(ha_fallback_active) = true;
              ESP_LOGE("fallback", "HA DOWN ‚Üí mode s√©curit√©");
            }
          } else if (id(ha_fallback_active)) {
            id(ha_fallback_active) = false;
            ESP_LOGI("fallback", "HA OK");
          }

          // --- 3) Mode actif
          std::string mode = id(ha_fallback_active)
              ? "fallback"
              : id(victron_mode).state.c_str();
          for (auto &c : mode) c = tolower(c);

          // --- 4) Tensions Victron
          const float V_BULK  = ${victron_voltage_bulk};
          const float V_ABS   = ${victron_voltage_absorption};
          const float V_FLOAT = ${victron_voltage_float};
          const float V_IDLE  = ${victron_voltage_idle};

          float target = V_FLOAT;

          // --- 5) Mode fallback
          if (mode == "fallback") {
            float bv = id(dps_output_voltage).state;

            if (bv > ${victron_fallback_voltage_threshold}) {
              target = V_IDLE;
              id(dps_output_sw).turn_off();
            } else {
              target = V_FLOAT;
              if (!id(dps_output_sw).state)
                id(dps_output_sw).turn_on();

              if (id(current_setting).state > ${victron_fallback_current_limit}) {
                id(current_setting).make_call()
                  .set_value(${victron_fallback_current_limit})
                  .perform();
              }
            }
          }

          // --- 6) Modes Victron normaux
          else if (mode == "bulk")       target = V_BULK;
          else if (mode == "absorption") target = V_ABS;
          else if (mode == "float")      target = V_FLOAT;
          else                            target = V_IDLE;

          // --- 7) Slew-rate 0.1V
          static float last = target;
          if (fabs(target - last) > 0.1f) {
            float step = (target > last) ? 0.1f : -0.1f;
            float vset = last + step;

            if ((step > 0 && vset > target) || (step < 0 && vset < target))
              vset = target;

            unsigned long now = millis();
            if (now - id(last_modbus_cmd) >= ${modbus_ready_delay}) {
              id(voltage_setting).make_call().set_value(vset).perform();
              id(last_modbus_cmd) = now;
              last = vset;
            }
          }

          // --- 8) Publication du texte de phase
          char buf_mode[48];
          if (id(ha_fallback_active)) sprintf(buf_mode, "Victron : FALLBACK");
          else                        sprintf(buf_mode, "Victron : %s", mode.c_str());
          id(charge_phase_text).publish_state(buf_mode);

          // ============================================================
          // 9) DUR√âE ACTIVE DE CHARGE (inchang√©)
          // ============================================================
          float v = id(dps_output_voltage).state;
          float a = id(dps_output_current).state;
          float power = v * a;

          static unsigned long last_t = millis();
          unsigned long now_t = millis();
          if (now_t < last_t) last_t = now_t;
          unsigned long elapsed_s = (now_t - last_t) / 1000;
          last_t = now_t;

          if (id(dps_output_sw).state && power > 10.0f)
            id(phase_active_time) += elapsed_s;

          unsigned long t = id(phase_active_time);
          char tbuf[24];
          sprintf(tbuf, "%02luh %02lum %02lus",
                  t / 3600, (t % 3600) / 60, t % 60);
          id(charge_phase_duration).publish_state(tbuf);

          // ============================================================
          // 10) √âNERGIE DPS (Wh) ‚Äî ACTIV√âE (comme en 1.6.5)
          // ============================================================
          static unsigned long last_energy_ts = millis();
          unsigned long now_energy = millis();
          if (now_energy < last_energy_ts) last_energy_ts = now_energy;

          float delta_h_energy = (now_energy - last_energy_ts) / 3600000.0f;
          last_energy_ts = now_energy;

          if (power > 0.5f)
            id(energy_wh) += power * delta_h_energy;

          // Publication du compteur DPS
          id(dps_energy_wh).publish_state(id(energy_wh));


  # ------------------- WATCHDOG DPS BLOQU√â -------------------
  - interval: ${watchdog_dps_interval}
    then:
      - lambda: |-
          static unsigned long last_change = millis();
          static float lv = 0, li = 0, lp = 0;
          bool changed = false;
          const float V_TOL = 0.05f;
          const float I_TOL = 0.10f;
          const float P_TOL = 2.0f;
          float v = id(dps_output_voltage).has_state() ? id(dps_output_voltage).state : -1;
          float i = id(dps_output_current).has_state() ? id(dps_output_current).state : -1;
          float p = id(dps_output_power).has_state()   ? id(dps_output_power).state   : -1;
          if (fabs(v - lv) > V_TOL) { lv = v; changed = true; }
          if (fabs(i - li) > I_TOL) { li = i; changed = true; }
          if (fabs(p - lp) > P_TOL) { lp = p; changed = true; }
          if (changed) {
            last_change = millis();
            return;
          }
          if (id(dps_output_sw).state && millis() - last_change > ${modbus_freeze_timeout}) {
            ESP_LOGW("modbus", "freeze d√©tect√© ‚Üí reset Modbus");
            id(reset_modbus_connection).execute();
            last_change = millis();
          }

  # ------------------- API -------------------
  - interval: ${watchdog_api_interval}
    then:
      - lambda: |-
          static unsigned long last = millis();
          if (id(api_connected).state) last = millis();
          if (millis() - last > ${api_reboot_timeout}) {
            ESP_LOGW("wifi", "reboot");
            id(restart_esp).press();
          }

  # ------------------- WATCHDOG CAN R48 -------------------
  - interval: ${watchdog_can_interval}
    then:
      - lambda: |-
          if (millis() < 15000) return;
          if (!id(dps_output_sw).state) return;
          if (!id(emerson_r48_dc_sw).state) return;
          static unsigned long last = millis();
          if (id(r48_output_current).has_state() && id(r48_output_current).state > 0.05f) {
            last = millis();
            return;
          }
          static unsigned long reset_ts = 0;
          if (millis() - last > 5000 && millis() - reset_ts > ${can_reset_timeout}) {
            reset_ts = millis();
            id(r48_dc_reset_short).execute();
          }

  # ------------------- WATCHDOG CHARGE BLOQU√âE -------------------
  - interval: ${watchdog_charge_blocked_interval}
    then:
      - lambda: |-
          static unsigned long last = millis();
          if (id(charger_active).state && id(dps_output_power).state > 20.0f)
            last = millis();
          if (id(charger_active).state && millis() - last > ${charge_blocked_timeout}) {
            id(dps_output_sw).turn_off();
            std::string vm = id(victron_mode).state.c_str();
            for (auto &c : vm) c = tolower(c);
            bool victron_ok = (vm == "bulk" || vm == "absorption" || vm == "float");
            if (victron_ok)
              id(dps_output_sw).turn_on();
          }

  # ------------------- WATCHDOG SURTENSION -------------------
  - interval: ${watchdog_overtension_interval}
    then:
      - lambda: |-
          static unsigned long ts = 0;
          float v = id(dps_output_voltage).state;
          if (v > ${overtension_threshold}) {
            if (!ts) ts = millis();
            if (v > ${overtension_critical_threshold} && millis() - ts > ${overtension_critical_delay})
              id(handle_critical_error).execute("üõë SURTENSION");
          } else {
            ts = 0;
          }
  # ------------------- WATCHDOG SURINTENSIT√â DPS -------------------
  - interval: 1s
    then:
      - lambda: |-
          static bool overload = false;
          static unsigned long t_over = 0;
          static unsigned long t_recover = 0;

          // V√©rifications de base
          if (!id(dps_output_sw).state) {
            overload = false;
            t_over = 0;
            t_recover = 0;
            return;
          }

          // Protection anti valeurs fant√¥mes Modbus
          if (!id(dps_output_current).has_state()) {
            ESP_LOGW("watchdog", "‚ö†Ô∏è I_DPS sans √©tat ‚Üí skip surintensit√©");
            return;
          }

          float I = id(dps_output_current).state;

          // --- Avertissement
          if (I >= 20.0f && I < 22.0f && !overload) {
            ESP_LOGW("watchdog", "‚ö†Ô∏è Courant √©lev√© : %.1f A", I);
          }

          // --- Surcharge confirm√©e : > 22A pendant >2s
          if (I >= 22.0f && !overload) {
            if (t_over == 0) t_over = millis();
            if (millis() - t_over > 2000) {
              ESP_LOGE("watchdog", "üõë SURINTENSIT√â >22A ‚Üí DPS OFF");
              overload = true;
              id(dps_output_sw).turn_off();
              id(charge_phase_text).publish_state("‚ö†Ô∏è Coupure surintensit√© DPS !");
            }
          } else {
            t_over = 0;
          }

          // --- Reprise automatique (si courant retombe √† 0-5A)
          if (overload && I <= 5.0f) {
            if (t_recover == 0) t_recover = millis();
            if (millis() - t_recover > 3000) {

              // Reprise uniquement si Victron OK
              if (id(victron_mode).has_state()) {
                std::string vm = id(victron_mode).state.c_str();
                for (auto &c : vm) c = tolower(c);
                bool ok = (vm == "bulk" || vm == "absorption" || vm == "float");

                if (ok) {
                  ESP_LOGI("watchdog", "üîÑ Reprise surintensit√© : courant normal ‚Üí DPS ON");
                  id(dps_output_sw).turn_on();
                }
              }

              overload = false;
              t_recover = 0;
            }
          } else {
            t_recover = 0;
          }

  # ------------------- WATCHDOG D√âMARRAGE DPS / FREEZE -------------------
  - interval: 10s
    then:
      - lambda: |-
          static int attempts = 0;
          static int cycles = 0;

          // Conditions de surveillance
          std::string vm = id(victron_mode).state.c_str();
          for (auto &c : vm) c = tolower(c);
          bool victron_ok = (vm == "bulk" || vm == "absorption" || vm == "float");

          if (!victron_ok || id(force_charge_mode)) {
            attempts = 0;
            return;
          }

          // --- DPS devrait √™tre ON mais ne l'est pas
          if (!id(dps_output_sw).state) {
            attempts++;
            ESP_LOGW("watchdog", "‚ö†Ô∏è DPS attendu ON mais OFF (tentative %d)", attempts);
          } else {
            attempts = 0;
            return;
          }

          // --- Trop de tentatives : soft reset DC + Modbus
          if (attempts >= 3) {
            attempts = 0;
            cycles++;
            ESP_LOGE("watchdog", "üßØ DPS fig√© ‚Üí soft reset DC / Modbus (cycle %d)", cycles);

            id(dps_output_sw).turn_off();
            id(emerson_r48_dc_sw).turn_off();
            id(modbus_ready) = false;

            delay(500);
            id(emerson_r48_dc_sw).turn_on();
            delay(500);
            id(dps_output_sw).turn_on();
          }

          // --- Trop de cycles ‚Üí mode s√©curit√©
          if (cycles >= 3) {
            ESP_LOGE("watchdog", "‚õî DPS instable ‚Üí ABANDON ‚Üí s√©curit√© activ√©e !");
            id(force_charge_mode) = false;
            id(dps_output_sw).turn_off();
            id(emerson_r48_ac_sw).turn_off();
            cycles = 0;

            id(charge_phase_text).publish_state("‚ö†Ô∏è DPS instable - Coupure s√©curit√© !");
          }

          // Si DPS ON, reset des cycles
          if (id(dps_output_sw).state)
            cycles = 0;

  # ------------------- WATCHDOG TEMP -------------------
  - interval: ${watchdog_temperature_interval}
    then:
      - lambda: |-
          if (!id(r48_output_temp).has_state()) return;
          float t = id(r48_output_temp).state;
          static bool fan = false;
          if (t >= ${temperature_fan_on} && !fan) {
            id(emerson_r48_fan_sw).turn_on();
            fan = true;
          }
          if (t >= ${temperature_critical}) {
            id(handle_critical_error).execute("üî• SURCHAUFFE");
          }
          if (t <= ${temperature_fan_off} && fan) {
            id(emerson_r48_fan_sw).turn_off();
            fan = false;
          }

  # ------------------- DC OFF IF DPS OFF -------------------
  - interval: ${watchdog_can_interval}
    then:
      - lambda: |-
          static bool cut = false;
          if (!id(dps_output_sw).state && id(emerson_r48_dc_sw).state && !cut) {
            id(emerson_r48_dc_sw).turn_off();
            cut = true;
          }
          if (id(dps_output_sw).state && !id(emerson_r48_dc_sw).state && cut) {
            id(dc_rearm_after_dps_on).execute();
            cut = false;
          }
  # ------------------- √âNERGIE R√âELLE C√îT√â BATTERIE -------------------
  - interval: 10s
    then:
      - lambda: |-
          if (!id(r48_output_current).has_state() || !id(r48_output_voltage).has_state())
            return;

          if (!id(dps_output_sw).state)
            return;

          // Puissance batterie = P_R48 * rendement
          float eff = id(dps_efficiency).state / 100.0f;
          float p = id(r48_output_current).state * id(r48_output_voltage).state * eff;

          static unsigned long last_energy_ts2 = millis();
          unsigned long now2 = millis();
          if (now2 < last_energy_ts2) last_energy_ts2 = now2;

          float delta_h = (now2 - last_energy_ts2) / 3600000.0f;
          last_energy_ts2 = now2;

          if (p > 0.5f) {
            id(battery_energy_wh_total) += p * delta_h;
          }

          // Publication HA
          id(battery_energy_wh).publish_state(id(battery_energy_wh_total));
          id(battery_energy_kwh).publish_state(id(battery_energy_wh_total) / 1000.0f);
